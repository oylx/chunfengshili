const test = () => {
  let t = new Date()
  let u = +t
  console.log(t, u);
}
test()
// 浏览器采用多进程架构有什么优势和劣势
// 1.chromium项目创建初期，webkit不属于谷歌。他们对苹果的东西不信任，而且各种页面渲染时候的崩溃也很大。那时候webkit在chromium里的地位就是个小小第三方库。所以需要把渲染放到另外个进程防止崩溃了影响主进程。
// 2.同样的，webkit那时候很多内存泄露。多进程能很大程度避免。一个进程关了，所有内存就回收了。当时谷歌还写文章鄙视了下那些说多进程占用内存多的人。
// 3.多进程安全性更好。如果blink被发现什么提权漏洞，例如写一段js就能控制整个chromium进程做任何事情，显然多进程可以把损失限制在渲染线程。渲染线程拿不到主进程的各种私密信息，例如别的域名下的密码
// 4.另外有个点大家没说的地方就是，webkit内部很多全局变量。如果要做到一个页面一个线程，理论上很难搞。谷歌其实考虑过想搞一个单进程多线程模式，后来发现不好搞就放弃了。。这个模式在移动平台还是有优势的。以前的手机性能和内存还很差。多进程很消耗内存。chromium刚移植到安卓上时，还是30几版本。性能和稳定性远不如webkit单进程。那时候安卓版chromium就是单进程模式。

// 为什么requestAnimationFrame(请求动画帧) 比setTimeout、setInterval有什么优势？怎么去应用？
// 1.由系统来决定回调函数的执行时机:requestAnimationFrame的步伐跟着系统的刷新步伐走。它能保证回调函数在屏幕每一次的刷新间隔中只被执行一次，这样就不会引起丢帧现象，也不会导致动画出现卡顿的问题。
// 2.CPU节能
// 使用setTimeout实现的动画，当页面被隐藏或最小化时，setTimeout 仍然在后台执行动画任务，由于此时页面处于不可见或不可用状态，刷新动画是没有意义的，完全是浪费CPU资源。而requestAnimationFrame则完全不同，当页面处理未激活的状态下，该页面的屏幕刷新任务也会被系统暂停，因此跟着系统步伐走的requestAnimationFrame也会停止渲染，当页面被激活时，动画就从上次停留的地方继续执行，有效节省了CPU开销。
// 3.函数节流
// 在高频率事件(resize,scroll等)中，为了防止在一个刷新间隔内发生多次函数执行，使用requestAnimationFrame可保证每个刷新间隔内，函数只被执行一次，这样既能保证流畅性，也能更好的节省函数执行的开销。

